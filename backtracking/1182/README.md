
# BOJ 1182 - 부분수열의 합

## 1. 문제 설명

* 크기 N의 정수 수열이 주어진다.
* 이 수열에서 **크기가 양수인 부분수열** 중, 합이 **정수 S**인 경우의 수를 구한다.
* 부분수열은 순서를 유지하며, 일부 원소를 선택하는 조합이다.
* 공집합(원소 0개 선택)은 제외해야 한다.

---

## 2. 내가 처음 잘못 생각한 이유

초기에는 `visited[]` 배열을 써서 **중복 없이 원소를 하나씩 사용하는 방식**으로 접근했다.

```cpp
for (int i = 0; i < N; i++) {
    if (visited[i]) continue;
    visited[i] = 1;
    func(k + board[i]);
    visited[i] = 0;
}
```

하지만 이 방식은 다음과 같은 문제가 있다:

* **순열 탐색** 방식이며, 부분수열이 아님
* **원소의 선택/비선택 여부가 아닌, 방문 순서 기반**으로 동작
* **공집합 처리 누락**

### 모든 가능한 수열을 고려하지 않음

---

## 3. 올바른 풀이 방식: 백트래킹

모든 원소에 대해 **선택 / 선택하지 않음** 두 가지 경우를 재귀적으로 탐색한다. 이게 부분수열 전체를 탐색하는 방법이다.

핵심 구조는 다음과 같다:

```cpp
void func(int idx, int sum) {
    if (idx == N) {
        if (sum == S) cnt++;
        return;
    }
    func(idx + 1, sum);             // 선택 안 함
    func(idx + 1, sum + arr[idx]);  // 선택함
}
```

---

## 4. S == 0인 경우 `cnt--` 하는 이유

* 아무것도 선택하지 않은 **공집합**도 합이 0이 되어 카운트됨
* 하지만 문제에서 공집합은 제외해야 하므로 마지막에 `cnt--` 필요

```cpp
if (S == 0) cnt--;  // 공집합 제외
```

대신, 선택한 원소 수를 같이 추적하면 더 명시적으로 처리할 수도 있다.

---

## 요약

* 부분수열의 합은 **선택/비선택 기반의 백트래킹 문제**
* `visited[]` 같은 순열 기반 탐색은 오답
* `S == 0` 처리 주의 (공집합 제거)
* 최대 2²⁰ = 1,048,576이므로 완전 탐색 가능

---
