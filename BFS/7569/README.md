# 3차원 토마토 문제 (BOJ 7569)

## 개요
익은 토마토가 인접한 토마토를 하루에 하나씩 익게 만들 수 있을 때, 모든 토마토가 익는 데 걸리는 최소 일수를 구하는 문제입니다.  
입력은 3차원 배열 형태로 주어지며, BFS를 통해 해결합니다.

---

## 문제 해결 접근

### 초반의 잘못된 접근
- 익은 토마토가 여러 개 있는 경우, 각각의 익은 토마토마다 BFS를 개별 실행했음
- 하지만 이 경우 **동시에 익어야 할 토마토들이 순차적으로 익어버리는 문제**가 발생함
- 따라서 BFS는 **모든 익은 토마토를 초기 상태로 큐에 넣고 단 한 번만 수행**해야 함

###  올바른 해결법
- 모든 익은 토마토 위치를 한 번에 큐에 넣고 BFS를 **동시 확산** 방식으로 수행
- 각 노드 방문 시, `day[z][y][x] = day[cur_z][cur_y][cur_x] + 1`로 날짜 기록

---

### 인덱스 실수
- `queue<tuple<int, int, int>>`를 사용할 때, `(z, y, x)` 순서로 저장했음에도
- 인덱스를 잘못 사용해 `day[x][y][z]`처럼 순서가 꼬이는 문제가 있었음
- 반드시 `get<0>() = z`, `get<1>() = y`, `get<2>() = x`로 정확하게 사용해야 함

---

## 핵심 로직

```cpp
while (!Q.empty()) {
    auto [z, y, x] = Q.front(); Q.pop();
    for (int d = 0; d < 6; d++) {
        int nz = z + dz[d];
        int ny = y + dy[d];
        int nx = x + dx[d];
        ...
        day[nz][ny][nx] = day[z][y][x] + 1;
    }
}
