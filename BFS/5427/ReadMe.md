# 🔥 불! (BOJ 5427)

## 1. 개요

상근이는 불이 난 건물 안에서 탈출해야 합니다.  
불은 매 초마다 상하좌우로 퍼지며 상근이는 벽을 통과할 수 없고 불이 붙은 칸이나 곧 붙을 칸으로도 이동할 수 없습니다.  
**건물의 가장자리에서 밖으로 벗어나면 탈출한 것으로 간주**하며, 최소 탈출 시간을 구해야 합니다.  
탈출이 불가능한 경우 `"IMPOSSIBLE"`을 출력합니다.

### 예시 입력
```
1
3 3
#@.
#..
###
```
### 예시 출력
```
2
```

## 2. 사용한 알고리즘

- **BFS (너비 우선 탐색)** 사용
    - 불의 전파 시간을 먼저 BFS로 계산
    - 이후 상근이의 이동 경로를 BFS로 계산하며 불보다 먼저 도착 가능한지 확인

---

## 3. 문제 해결 접근

### 3-1. 답을 찾으면 바로 탈출해야 함

상근이가 **경계를 벗어나는 순간 즉시 탈출 성공**이므로, 해당 시점에 바로 `cout`으로 출력하고 BFS를 종료해야 함

```cpp
if (nx < 0 || nx >= h || ny < 0 || ny >= w) {
    cout << sang_board[cur.X][cur.Y] + 1 << '\n';
    is_escaped = true;
    break; // 더 탐색할 필요 없음
}
```
- 해결방법
  - break로는 for 루프만 탈출하므로, `while (!sang_q.empty() && !is_escaped)` 조건으로 BFS 루프도 함께 빠져나가야 함

### 3-2. fire_board를 0으로 초기화하면 안 됨
fire_board를 0으로 초기화하면
불이 아직 도달하지 않은 칸과 불의 시작점(0초) 을 구분할 수 없게 되어 오작동이 발생함

```cpp
if (sang_time + 1 >= fire_board[nx][ny]) continue;
```
위 조건은 fire_board[nx][ny] == 0인 모든 칸을 차단하므로
불이 오지 않은 빈 칸에도 상근이가 가지 못하게 되어 틀린 결과가 나올 수 있음


- 해결 방법
  - fire_board를 INF 로 초기화하고 불이 도달한 칸만 0 이상 값으로 설정
    이렇게 하면  불이 도달하지 않은 칸이 INF이므로 sang_time + 1 보다 크므로 문제 해결 가능