# BFS with One-Time Magical Shoes

격자형 보드 위에서 `(m-1, 0)` → `(0, n-1)`로 이동하는 **최단 경로** 찾기

단, **한 번만 사용할 수 있는 신비한 신발** 존재 (2칸 이동, 장애물 무시)

---

## 문제 요약

- 격자 크기: `m × n`
- 출발점: 왼쪽 아래 `(m-1, 0)`
- 도착점: 오른쪽 위 `(0, n-1)`
- `hole`에 포함된 칸은 **지날 수 없음**
- 한 번만 사용할 수 있는 **신비한 신발** 존재:
    - 상하좌우 중 한 방향으로 **2칸 점프**
    - 단 한 번만 사용 가능

---

## 알고리즘: 상태 확장 BFS

일반 BFS에서 한 번만 사용할 수 있는 능력(신발)을 도입하기 위해 **상태를 확장**해서 처리

- 각 위치 `(x, y)`에 대해 **신발을 썼는지 여부 (`used`)** 를 함께 관리
- 방문 여부와 거리 기록은 3차원 배열로 구현:

```cpp
int visited[1000][1000][2];
int board[1000][1000][2];
```

```cpp
queue<tuple<int, int, int>> Q;
Q.push({startX, startY, 0}); // 0: 아직 신발 안 씀
```
→ BFS 큐에는 (x, y, used) 형태로 상태를 넣음

이동 방식
일반 이동 (상하좌우 1칸 이동)

used == 0 또는 used == 1 상태 모두에서 가능

기존 BFS와 동일한 방식

신발 이동 (2칸 점프)

used == 0일 때만 가능 (신발을 아직 사용하지 않은 상태)

한 방향으로 2칸 이동하며, 점프한 칸은 갈 수 있어야 함

점프 후 상태는 used == 1로 변경됨

---
## 헷갈렸던 포인트 ❗
### 1. tuple 사용법
```cpp
tuple<int, int, int> t = make_tuple(1, 2, 3);
int a = get<0>(t); // 첫 번째 요소
int b = get<1>(t); // 두 번째 요소
int c = get<2>(t); // 세 번째 요소


tuple<int,int,int> cur = Q.front();
int x = get<0>(cur);
int y = get<1>(cur);
int used = get<2>(cur);
```
### 2. 신발 사용 시 board 인덱스 실수
```cpp
board[nx][ny][1] = board[curX][curY][0] + 1; // 사용 전의 상태 [0]에서 +1
```
→ 신발을 "지금" 사용하는 것이므로 현재 used == 0인 상태
→ 실수로 board[curX][curY][1]을 참조하면 잘못된 거리 계산이 됨

### 3. 일반 이동과 신발 이동을 동시에 시도해도 되는가?
### → 된다. 문제가 없다.
```cpp
visited[x][y][0]; visited[x][y][1];
```
→별개의 상태로 관리되기 때문에
중복 처리X

#### BFS는 항상 먼저 도달하는 짧은 경로를 기준으로 탐색하므로
#### 여러 상태가 동시에 진행되어도 정답이 바뀌지 않음

```text
예시:

(x, y, 0) → 일반 이동으로 도달
(x, y, 1) → 신발 사용 후 도달
```
서로 다른 상태이므로 동시에 존재 가능