# 재귀적으로 색종이 개수 세기

이 프로그램은 정사각형 종이를 재귀적으로 4등분하면서, 각 영역이 모두 같은 색으로 구성되어 있는지를 판단하여 흰색(0)과 파란색(1) 색종이의 개수를 세는 알고리즘입니다.

## 1. 문제 개요

- 입력: `N x N` 크기의 2차원 배열 (`0` 또는 `1`로 채워짐)
- 목표: 전체 종이를 가능한 작은 단위까지 분할하면서, 모든 칸이 같은 색인 영역을 찾고 그 개수를 세기

## 2. 핵심 로직: `paper` 함수의 절차적 동작

1. **현재 구역이 같은 색으로만 이루어졌는지 확인**
    - `isSame(board, n, r, c)`를 호출하여 `(r, c)`부터 시작하는 `n x n` 구역이 전부 같은 값인지 검사
    - 행과 열을 각각 반복문으로 순회하면서 인접한 값이 다른 경우 false를 반환

2. **만약 같은 색으로 이루어졌다면**
    - 해당 색깔(0이면 `white`, 1이면 `blue`)의 카운트를 증가시킴
    - 더 이상 분할할 필요 없으므로 return

3. **같은 색이 아니라면**
    - 정사각형을 네 개로 나누고(`n/2` 크기), 각 사분면에 대해 `paper()`를 재귀 호출
        - 왼쪽 위: `(r, c)`
        - 오른쪽 위: `(r, c + n/2)`
        - 왼쪽 아래: `(r + n/2, c)`
        - 오른쪽 아래: `(r + n/2, c + n/2)`

4. **이 과정을 반복**
    - 더 이상 나눌 수 없거나 모두 같은 색이 될 때까지 위 과정을 반복

## 3. 정리된 알고리즘 흐름

```
paper(board, n, r, c):
    if 현재 영역이 모두 같은 색인가?
        해당 색의 개수 증가
        return
    else
        네 구역으로 나눠서 각각 재귀 호출
```

## 4. 실행 예시

예를 들어 `8 x 8` 보드가 주어졌을 때, 다음과 같은 출력이 나올 수 있습니다:

```
입력
8
1 1 0 0 0 0 1 1
1 1 0 0 0 0 1 1
0 0 0 0 1 1 0 0
0 0 0 0 1 1 0 0
1 0 0 0 1 1 1 1
0 1 0 0 1 1 1 1
0 0 1 1 1 1 1 1
0 0 1 1 1 1 1 1

출력
9
7
```

## 5. 결론

이 알고리즘은 **분할 정복(Divide and Conquer)**의 전형적인 예로, 한 문제를 더 작은 문제들로 쪼개고, 그 결과를 모아서 전체 해답을 얻는 방식입니다. 문제를 절차적으로 따라가며 `isSame → 재귀 분할 → 카운트` 순으로 수행됩니다.
