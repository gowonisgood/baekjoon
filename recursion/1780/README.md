2초 동안 생각함


# 종이의 개수 (BOJ 1780) 풀이 ReadMe

## 1. 프로젝트 개요

* 분할정복(재귀)을 이용해 N×N 크기의 행렬을 3×3 블록으로 분할하며, 각 블록이 모두 같은 값(-1, 0, 1)으로 채워졌는지 검사하여 종이를 세는 프로그램입니다.

## 2. 문제 설명

* 입력: 3^k (k ≥ 0) 크기의 정사각 행렬 N×N (N ≤ 3^7)
* 각 칸의 값은 -1, 0, 1 중 하나
* 행렬을 모두 동일한 숫자로 표현되는 블록으로 재귀적으로 분할하며, 각 블록의 개수를 세어 출력

## 3. 솔루션 개요

1. 전체 영역이 모두 같은 값인지 확인하는 함수 `isSame()` 구현
2. 블록이 동일하지 않으면 3등분하여 총 9개 블록에 대해 재귀 호출
3. 블록이 동일하면 전역 카운터(`mone`, `zero`, `pone`)를 증가

## 4. 주요 함수 설명

### 4.1 `bool isSame(int board[][2190], int n, int r, int c)`

* `r`, `c`는 검사 시작 좌표, `n`은 블록의 한 변 길이
* 인접 가로와 세로 방향의 요소를 비교하여 모두 같은지 확인
* 동일하지 않은 쌍이 발견되면 `false` 반환, 끝까지 동일하면 `true` 반환

### 4.2 `void paper(int board[][2190], int n, int r, int c)`

* **재귀 함수**로, 크기 `n`인 블록의 시작 좌표 (`r`, `c`)를 인자로 받음
* `isSame()` 결과에 따라:

    * **동일**: `board[r][c]` 값을 확인해 전역 카운터(`mone`, `zero`, `pone`) 증가
    * **불일치**: `n/3` 크기로 3×3 분할 후 9회 재귀 호출

## 5. 재귀적 분할 흐름

```
paper(board, N, 0, 0)
├─ isSame? false
│  ├─ paper(board, N/3, 0, 0)
│  ├─ paper(board, N/3, 0, N/3)
│  ├─ ... 총 9개
├─ isSame? true → 카운터 증가
```

* 재귀 깊이 최대 k (N=3^k)

## 6. 동작 절차

1. `main()`에서 `N`과 `board` 입력
2. 전역 카운터 초기화(`mone = zero = pone = 0`)
3. `paper(board, N, 0, 0)` 호출
4. 분할→재귀 검사→카운팅 과정 반복
5. 결과 출력

## 7. 시간 및 공간 복잡도

* **시간 복잡도**: 최악의 경우 T(n) = 9T(n/3) + O(n^2) ⇒ O(n^2) (각 단계에서 전체 영역 검사)
* **공간 복잡도**: 재귀 호출 스택 깊이 O(k) = O(log\_3 N)

## 8. 사용 방법

```bash
g++ -std=c++17 -O2 -o solve solve.cpp
./solve < input.txt > output.txt
```

## 9. 빌드 및 실행 예시

```bash
$ g++ -std=c++17 -O2 -o paper1780 paper1780.cpp
$ ./paper1780
9
0 0 0 1 1 1 -1 -1 -1
... (입력 데이터)
# 결과
10
12
11
```

## 10. 라이선스

MIT License
